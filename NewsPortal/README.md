## Модуль D7 
### Изменения от 2023.06.15
- Установлен Redis.
- Установлен Celery.
- Произведена конфигурация Django для соединения всех компонент системы.
- Реализована рассылку уведомлений подписчикам после создания новости.
- Реализована еженедельная рассылка с последними новостями (каждый понедельник в 8:00 утра).
- (для корректной работы Crontab в настройках изменен параметр TIME_ZONE = 'Asia/Krasnoyarsk' )
***
## Модуль D8 
### Изменения от 2023.06.16

Реализована практика кэширования данных на диск,  
добавлены настройки в файл settings.py:
```
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': os.path.join(BASE_DIR, 'cache_files'),
        # Указываем, куда будем сохранять кэшируемые файлы!
        # Не забываем создать папку cache_files внутри папки с manage.py!
    }
}
```

1. Проверен механизм кэширование страниц в файле urls.py:
  - конкретной новости на 5 минут: ```cache_page(60*5)(PostDetail.as_view())```
  - главной страницы на 1 минуту: ```cache_page(60)(PostList.as_view())```
_Примечание: механизм кэширования страниц закомментирован 2023.06.19_
2. Проверен механизм кэширования элементов HTML, в частности dropdown в навбаре на 30 сек., т.о. пользователь может разлогиниться, но информация о данном событии
  будет доступна только после обновления страницы через 30 сек
- Для кэширования использовался шаблон ___templates/flatpages/default.html___
- Имя тэга в шаблоне: ```{% block dropdown %}```

_Примечание: кэширование элементов страниц закомментировано 2023.06.19)_
3. 2023.06.19 Добавлен механизм кэширования страницы: детали новости/статьи кэшируются до тех пор, пока они не изменятся.
Данная реализация обеспечивается двумя этапами:
- в view.py в дженерик class PostDetail(DetailView) добавлен следующий код:
```
def get_object(self, *args, **kwargs):  # переопределяем метод получения объекта, как ни странно
        # кэш очень похож на словарь, и метод get действует так же.
        # Он забирает значение по ключу, если его нет, то забирает None.
        obj = cache.get(f'post-{self.kwargs["pk"]}', None)

        # если объекта нет в кэше, то получаем его и записываем в кэш
        if not obj:
            obj = super().get_object(queryset=self.queryset)
            cache.set(f'post-{self.kwargs["pk"]}', obj)
            return obj 
```
Т.е. если объекта нет в кэше, то мы берём его из БД и кэшируем, а если есть, то сразу берём из кэша и возвращаем.
Когда объект меняется его надо удалять из кэша, чтобы ключ сбрасывался и больше не находился
- для этого в models.py для class Post(models.Model) переопределим метод save:
```
    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)  # сначала вызываем метод родителя, чтобы объект сохранился
        cache.delete(f'post-{self.pk}')  # затем удаляем его из кэша, чтобы сбросить е
```
***
## Модуль D13 
### Изменения от 2023.07.21
Задание.
В консоль должны выводиться все сообщения уровня DEBUG и выше, включающие время, уровень сообщения, сообщения. Для сообщений WARNING и выше дополнительно должен выводиться путь к источнику события (используется аргумент pathname в форматировании). А для сообщений ERROR и CRITICAL еще должен выводить стэк ошибки (аргумент exc_info). Сюда должны попадать все сообщения с основного логгера django.
В файл general.log должны выводиться сообщения уровня INFO и выше только с указанием времени, уровня логирования, модуля, в котором возникло сообщение (аргумент module) и само сообщение. Сюда также попадают сообщения с регистратора django.
В файл errors.log должны выводиться сообщения только уровня ERROR и CRITICAL. В сообщении указывается время, уровень логирования, само сообщение, путь к источнику сообщения и стэк ошибки. В этот файл должны попадать сообщения только из логгеров django.request, django.server, django.template, django.db.backends.
В файл security.log должны попадать только сообщения, связанные с безопасностью, а значит только из логгера django.security. Формат вывода предполагает время, уровень логирования, модуль и сообщение.
На почту должны отправляться сообщения уровней ERROR и выше из django.request и django.server по формату, как в errors.log, но без стэка ошибок.
Более того, при помощи фильтров нужно указать, что в консоль сообщения отправляются только при DEBUG = True, а на почту и в файл general.log — только при DEBUG = False.


- Реализован стандартный фильтр проверки параметра settings.DEBUG, определяющий способ формирования и вывода логов с помощью следующей инструкции:
```python
    'filters': {
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
```
- для решения задачи в файле settings создан словарь LOGGING = {},в котором определены 7 handlers, обеспечивающие обработку событий 6 loggers, при этом форматированный вывод обеспечивался с помощью 4 formaters.
***