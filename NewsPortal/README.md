## Модуль D7 
### Изменения от 2023.06.15
- Установлен Redis.
- Установлен Celery.
- Произведена конфигурация Django для соединения всех компонент системы.
- Реализована рассылку уведомлений подписчикам после создания новости.
- Реализована еженедельная рассылка с последними новостями (каждый понедельник в 8:00 утра).
- (для корректной работы Crontab в настройках изменен параметр TIME_ZONE = 'Asia/Krasnoyarsk' )
***
## Модуль D8 
### Изменения от 2023.06.16

Реализована практика кэширования данных на диск,  
добавлены настройки в файл settings.py:
```
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': os.path.join(BASE_DIR, 'cache_files'),
        # Указываем, куда будем сохранять кэшируемые файлы!
        # Не забываем создать папку cache_files внутри папки с manage.py!
    }
}
```

1. Проверен механизм кэширование страниц в файле urls.py:
  - конкретной новости на 5 минут: ```cache_page(60*5)(PostDetail.as_view())```
  - главной страницы на 1 минуту: ```cache_page(60)(PostList.as_view())```
_Примечание: механизм кэширования страниц закомментирован 2023.06.19_
2. Проверен механизм кэширования элементов HTML, в частности dropdown в навбаре на 30 сек., т.о. пользователь может разлогиниться, но информация о данном событии
  будет доступна только после обновления страницы через 30 сек
- Для кэширования использовался шаблон ___templates/flatpages/default.html___
- Имя тэга в шаблоне: ```{% block dropdown %}```

_Примечание: кэширование элементов страниц закомментировано 2023.06.19)_
3. 2023.06.19 Добавлен механизм кэширования страницы: детали новости/статьи кэшируются до тех пор, пока они не изменятся.
Данная реализация обеспечивается двумя этапами:
- в view.py в дженерик class PostDetail(DetailView) добавлен следующий код:
```
def get_object(self, *args, **kwargs):  # переопределяем метод получения объекта, как ни странно
        # кэш очень похож на словарь, и метод get действует так же.
        # Он забирает значение по ключу, если его нет, то забирает None.
        obj = cache.get(f'post-{self.kwargs["pk"]}', None)

        # если объекта нет в кэше, то получаем его и записываем в кэш
        if not obj:
            obj = super().get_object(queryset=self.queryset)
            cache.set(f'post-{self.kwargs["pk"]}', obj)
            return obj 
```
Т.е. если объекта нет в кэше, то мы берём его из БД и кэшируем, а если есть, то сразу берём из кэша и возвращаем.
Когда объект меняется его надо удалять из кэша, чтобы ключ сбрасывался и больше не находился
- для этого в models.py для class Post(models.Model) переопределим метод save:
```
    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)  # сначала вызываем метод родителя, чтобы объект сохранился
        cache.delete(f'post-{self.pk}')  # затем удаляем его из кэша, чтобы сбросить е
```
***